C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE STATION
OBJECT MODULE PLACED IN Station.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe Station.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include "compiler_defs.h"
   2          #include "C8051F340_defs.h"
   3          #include <communication.h>
   4          //-----------------------------------------------------------------------------
   5          // Global CONSTANTS
   6          //-----------------------------------------------------------------------------
   7          
   8          #define SYSCLK      12000000           // SYSCLK frequency in Hz
   9          #define BAUDRATE      9600           // Baud rate of UART in bps
  10          
  11          
  12          //-----------------------------------------------------------------------------
  13          // Function PROTOTYPES
  14          //-----------------------------------------------------------------------------
  15          
  16          void SYSCLK_Init (void);
  17          void UART0_Init (void);
  18          void PORT_Init (void);
  19          void UART1_Init (void);
  20          
  21          void Delay(float DTime);
  22          void AccessTablet(ETabletCommand Command);
  23          void Init_Device(void);
  24          
  25          void Timer2_Init();
  26          void putchar(unsigned char cData);
  27          
  28          
  29          xdata TPacker Packer ;
  30          unsigned char RxTimeOutCount=0; // UART 接收超時時間設定
  31          unsigned char RxTimeOutCountTimer3 = 0;// UART 接收超時時間設定
  32          unsigned char *Pointer_Packer = &Packer.UART_Mark;
  33          unsigned char *CasetPointer_Packer = &Packer.UART_Mark;
  34          unsigned char CIndex = 0;
  35          bit     IsRxTimeOut =0; 
  36          bit     IsRxTimeOutTimer3 =0;   
  37          bit IsRxCommand=0;
  38          sbit ss  = P1^2;
  39          sbit Switch = P0^2;
  40          sbit LED    = P0^3;
  41          bit CasseteSEL = 1;
  42          
  43          //====test
  44          void Putchar(unsigned char cData);
  45          
  46          //-----------------------------------------------------------------------------
  47          // Global Variables
  48          //-----------------------------------------------------------------------------
  49          
  50          #define UART_BUFFERSIZE 80
  51          unsigned char TX_Ready =1;
  52          static char Byte;
  53          xdata unsigned int RevTemp=0;
  54          xdata ECasseteNum Tablet;
  55          unsigned char CASInfoTage = 0;
C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 2   

  56          unsigned char Finish = 0,Fail = 0;
  57          unsigned char CassetCount=0;
  58          unsigned char address = 0;
  59          bit IsDrugTimeOut = 0;
  60          
  61          unsigned char STX = 2;
  62          unsigned char ETX = 3;
  63          void UART1_Init (void){
  64   1              SBRLL1    = 0x8F;
  65   1          SBRLH1    = 0xFD;
  66   1          SCON1     = 0x10;           
  67   1          SMOD1     = 0x0c;
  68   1          SBCON1    = 0x43;  
  69   1              EIE2 = 0x02;//開啟UART1中斷
  70   1              //EIP2 = 0x02;//提高UART1中斷優先權
  71   1      }
  72          //-----------------------------------------------------------------------------
  73          void Timer2_Init(){
  74   1              TMR2CN = 0x00;
  75   1              TMR2L  = 0x00;
  76   1              TMR2H  = 0x00;
  77   1          ET2    = 1;
  78   1      }
  79          void Timer3_Init(){
  80   1              TMR3CN = 0x00;
  81   1              TMR3L  = 0xFF;
  82   1              TMR3H  = 0xFF;
  83   1          EIE1  |= 0x80;
  84   1      }
  85          void Putchar(unsigned char cData)
  86          {
  87   1              unsigned int i=10000;
  88   1              while( TX_Ready == 0) ;
  89   1              TX_Ready = 0;
  90   1              SBUF0 = cData;
  91   1              while(i--);     
  92   1      }
  93          void UART1_Putchar(unsigned char cData)
  94          {
  95   1              unsigned int i=10000;
  96   1              while( (SCON1 & 0x20) ==0) ;
  97   1              SBUF1 = cData;
  98   1              while(i--);     
  99   1      }
 100          
 101          void Init_Device(void)
 102          {
 103   1              PCA0MD &= ~0x40; 
 104   1              PORT_Init();                        // Initialize Port I/O
 105   1          SYSCLK_Init ();                     // Initialize Oscillator
 106   1          UART0_Init();
 107   1              UART1_Init();
 108   1              Timer2_Init();
 109   1              Timer3_Init();
 110   1      }
 111          int DropLimit = 0;
 112          unsigned char CasetBCC = 0x00;
 113          void main (void)
 114          {
 115   1              Init_Device();
 116   1              Packer.UART_Mark = UART_Mark;
 117   1              Packer.Cast_Mark = UART_Mark;
C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 3   

 118   1              ss = 1;
 119   1              LED = 1;                                       // enable)
 120   1          EA = 1;
 121   1      
 122   1              while(1)
 123   1              {
 124   2      //              Putchar(TabletCommand_Return);
 125   2                      if(Packer.Tablet.Command != TabletCommand_Idel)
 126   2                      {
 127   3                              AccessTablet(Packer.Tablet.Command);//send Command;
 128   3                              Delay(12500);
 129   3                              Finish = 0;Fail = 0;
 130   3                              Packer.Tablet.State = TabletState_Busy;
 131   3                              while((Finish + Fail) < CassetCount) //&& !IsDrugTimeOut)//wait return; 
 132   3                              {
 133   4                                      for(address = 0;address < CassetCount; address++)
 134   4                                      {
 135   5                                              if(Packer.CasseteInfo[address].State == TabletState_Sucess)
 136   5                                                      continue;
 137   5                                              Packer.Tablet.State = TabletState_Busy;
 138   5                                              Putchar(UART_Mark) ;
 139   5                                              Putchar(TabletCommand_Return);
 140   5                                              CasetBCC = TabletCommand_Return;
 141   5                                              Putchar(Packer.CasseteInfo[address].HNumber);
 142   5                                              CasetBCC ^= Packer.CasseteInfo[address].HNumber;
 143   5                                              Putchar(Packer.CasseteInfo[address].TNumber);
 144   5                                              CasetBCC ^= Packer.CasseteInfo[address].TNumber;
 145   5                                              Putchar(Packer.CasseteInfo[address].SNumber);
 146   5                                              CasetBCC ^= Packer.CasseteInfo[address].SNumber;
 147   5                                              Putchar(ETX);
 148   5                                              CasetBCC ^= ETX;
 149   5                                              Putchar(CasetBCC);
 150   5                                              Delay(1000);
 151   5                                              Packer.CasseteInfo[address].State =Packer.Tablet.State;// TbltState;//Packer.Tablet.State;
 152   5                              
 153   5                                              if(Packer.CasseteInfo[address].State == TabletState_Sucess)
 154   5                                                      Finish ++;      
 155   5                                              else if(Packer.CasseteInfo[address].State == TabletState_Fail)  
 156   5                                                      Fail ++;
 157   5                                              else
 158   5                                                      Packer.CasseteInfo[address].State = TabletState_Busy;
 159   5                                      }
 160   4                                      DropLimit++;
 161   4                                      if(DropLimit > 0x0100)
 162   4                                              break;
 163   4                              }                       
 164   3                              if(Finish == CassetCount)
 165   3                              {
 166   4                                      Packer.Station.State = StationState_Finish;
 167   4                                      Packer.Tablet.Command = TabletCommand_Idel;
 168   4                              }
 169   3                              else //if(IsDrugTimeOut)
 170   3                              {
 171   4                                      for(address = 0;address < CassetCount; address++)
 172   4                                      {
 173   5                                              if(Packer.CasseteInfo[address].State == TabletState_Busy)
 174   5                                                      Packer.CasseteInfo[address].State = TabletState_Fail;
 175   5                                      }
 176   4                                      Packer.Tablet.Command = TabletCommand_PackStop;
 177   4                                      Packer.Station.State = StationState_Error;
 178   4                              }
 179   3                              DropLimit = 0;
C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 4   

 180   3                              
 181   3                      }
 182   2              }
 183   1      }
 184          //----------------------------------------------------------------------------------
 185          
 186          void AccessTablet(ETabletCommand Command)
 187          {
 188   1              unsigned int i=0;
 189   1              Packer.Tablet.CasseteNum = 0x01;                                         
 190   1              for(i = 0;i<CassetCount;i++){
 191   2      
 192   2                      Putchar(UART_Mark) ;
 193   2      
 194   2                      Putchar(Command);       
 195   2                      CasetBCC = Command;
 196   2                      Putchar(Packer.CasseteInfo[i].HNumber);
 197   2                      CasetBCC ^= Packer.CasseteInfo[i].HNumber;
 198   2                      Putchar(Packer.CasseteInfo[i].TNumber);
 199   2                      CasetBCC ^= Packer.CasseteInfo[i].TNumber;
 200   2                      Putchar(Packer.CasseteInfo[i].SNumber);
 201   2                      CasetBCC ^= Packer.CasseteInfo[i].SNumber;
 202   2                      Putchar(Packer.CasseteInfo[i].QTYTNum);
 203   2                      CasetBCC ^= Packer.CasseteInfo[i].QTYTNum;
 204   2                      Putchar(Packer.CasseteInfo[i].QTYSNum);
 205   2                      CasetBCC ^= Packer.CasseteInfo[i].QTYSNum;
 206   2                      Putchar(ETX);
 207   2                      CasetBCC ^= ETX;
 208   2                      Putchar(CasetBCC);
 209   2                      Packer.CasseteInfo[i].State = TabletState_Busy;
 210   2              }       
 211   1      
 212   1              IsRxCommand =0;
 213   1              /*
 214   1              while(!IsRxCommand) 
 215   1              {
 216   1                      if (i++ >= 12000)       
 217   1                      {
 218   1                              i=0;
 219   1                              Pointer_Packer = &Packer.UART_Mark;
 220   1                              Packer.UART_Mark = UART_NoMark ;
 221   1                              return;
 222   1                      }
 223   1              }*/
 224   1              Pointer_Packer = &Packer.UART_Mark ;
 225   1              
 226   1      }
 227          void Delay(float time)
 228          {
 229   1      
 230   1              while(time --);
 231   1      
 232   1      }
 233          //-----------------------------------------------------------------------------
 234          
 235          void PORT_Init (void)
 236          {
 237   1         P0MDOUT |= 0x10;                    // Enable UTX as push-pull output
 238   1         XBR0     = 0x01;                    // Enable UART on P0.4(TX) and P0.5(RX)
 239   1         XBR1     = 0x40;                    // Enable crossbar and weak pull-ups
 240   1         XBR2     = 0x01;
 241   1      }
C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 5   

 242          //-----------------------------------------------------------------------------
 243          
 244          void SYSCLK_Init (void)
 245          {
 246   1         OSCICN |= 0x03;                     // Configure internal oscillator for
 247   1                                             // its maximum frequency
 248   1         RSTSRC  = 0x04;                     // Enable missing clock detector
 249   1      }
 250          
 251          void UART0_Init (void)
 252          {
 253   1         SCON0 = 0x10;                       // SCON0: 8-bit variable bit rate
 254   1                                             //        level of STOP bit is ignored
 255   1                                             //        RX enabled
 256   1                                             //        ninth bits are zeros
 257   1         TH1 = -(SYSCLK/BAUDRATE/2/4);
 258   1         CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
 259   1         CKCON |=  0x01;
 260   1      
 261   1         TL1 = TH1;                          // init Timer1
 262   1         TMOD &= ~0xf0;                      // TMOD: timer 1 in 8-bit autoreload
 263   1         TMOD |=  0x20;
 264   1         TR1 = 1;                            // START Timer1
 265   1         TX_Ready = 1;                       // Flag showing that UART can transmit
 266   1         IP |= 0x10;                         // Make UART high priority
 267   1         ES0 = 1;                            // Enable UART0 interrupts
 268   1      
 269   1      }
 270          
 271          //-----------------------------------------------------------------------------
 272          void Timer2_ISR (void) interrupt INTERRUPT_TIMER2 
 273          {
 274   1              TF2H=0;
 275   1              if (RxTimeOutCount ++ >=3)
 276   1              {
 277   2                      TR2 =0;
 278   2                      TMR2H = 0x00;
 279   2                      TMR2L = 0x00;
 280   2                      RxTimeOutCount=0;
 281   2                      Pointer_Packer =&Packer.Station.Command;
 282   2                      IsRxTimeOut =1;
 283   2              }
 284   1      }
 285          //-----------------------------------------------------------------------------
 286          
 287          void CommandANAY()
 288          {       
 289   1              unsigned char cstnp = 0;
 290   1              CassetCount = 0;
 291   1              for(cstnp = 1;cstnp < CIndex;cstnp+=5 )
 292   1              {
 293   2                      Tablet.HNumber = Packer.RecevieData[cstnp];
 294   2                      Tablet.TNumber = Packer.RecevieData[cstnp+1];
 295   2                      Tablet.SNumber = Packer.RecevieData[cstnp+2];
 296   2                      Tablet.QTYTNum = Packer.RecevieData[cstnp+3];
 297   2                      Tablet.QTYSNum = Packer.RecevieData[cstnp+4];
 298   2                      RevTemp = (Tablet.HNumber & 0x0F) * 100 +
 299   2                                        (Tablet.TNumber & 0x0F) *  10 +
 300   2                                        (Tablet.SNumber & 0x0F) ;
 301   2                      if((RevTemp / 20) == P4 || RevTemp >= 100)
 302   2                      {
 303   3                              Packer.CasseteInfo[CassetCount].HNumber =  Tablet.HNumber;
C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 6   

 304   3                              Packer.CasseteInfo[CassetCount].TNumber =  Tablet.TNumber;
 305   3                              Packer.CasseteInfo[CassetCount].SNumber =  Tablet.SNumber;
 306   3                              Packer.CasseteInfo[CassetCount].QTYTNum =  Tablet.QTYTNum;
 307   3                              Packer.CasseteInfo[CassetCount].QTYSNum =  Tablet.QTYSNum;
 308   3                              Packer.CasseteInfo[CassetCount].State = TabletState_Busy;
 309   3                              CassetCount++;
 310   3                      }
 311   2      
 312   2              }
 313   1      }
 314          
 315          void RunCommand()
 316          {
 317   1              unsigned char cstnp=0;  
 318   1      
 319   1              if(Packer.RecevieData[0] == EStationCommand_Return)
 320   1              {
 321   2                      for(cstnp = 0;cstnp<CassetCount;cstnp++)
 322   2                      {
 323   3                              if(Packer.CasseteInfo[cstnp].HNumber ==  Packer.RecevieData[1] &&
 324   3                                 Packer.CasseteInfo[cstnp].TNumber ==  Packer.RecevieData[2] &&
 325   3                              Packer.CasseteInfo[cstnp].SNumber ==  Packer.RecevieData[3] )
 326   3                              {
 327   4                                      UART1_Putchar(UART_Mark);
 328   4                                      UART1_Putchar(Packer.CasseteInfo[cstnp].State);
 329   4                              }
 330   3                      }
 331   2              }
 332   1              else if(Packer.RecevieData[0] != EStationCommand_Idel)
 333   1              {
 334   2                      CommandANAY();
 335   2                      if(CassetCount == 0)
 336   2                              return;
 337   2                      Packer.Station.Command = Packer.RecevieData[0];
 338   2                      Packer.Tablet.Command = Packer.RecevieData[0];
 339   2                      Packer.Station.State =  StationState_Busy;
 340   2              }
 341   1      
 342   1      }
 343          byte BCCTemp,BCC;
 344          void UART1_ISR(void)   interrupt 16 //接收BOARD的資料
 345          {
 346   1              EIE2 &= ~0x02;
 347   1              if (SCON1 & 0x02)               // TI1
 348   1              {
 349   2                      SCON1 &= (~0x02);
 350   2              }
 351   1      
 352   1              if (SCON1 & 0x01)               // RI1
 353   1              {
 354   2                      SCON1 &= (~0x01);
 355   2                      *(Pointer_Packer) = SBUF1;
 356   2                      BCCTemp ^= SBUF1;
 357   2                      if(Pointer_Packer == &Packer.UART_Mark)
 358   2                      {
 359   3                              if (Packer.UART_Mark == UART_Mark)
 360   3                              {
 361   4                                      Packer.UART_Mark = UART_NoMark ;
 362   4                                      Pointer_Packer = &Packer.RecevieData[CIndex];
 363   4                              }
 364   3                              else
 365   3                              {       
C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 7   

 366   4                                      Pointer_Packer = &Packer.UART_Mark;
 367   4                              }
 368   3                      }
 369   2                      else if(Pointer_Packer == &Packer.RecevieData[CIndex])
 370   2                      {
 371   3                              if(CIndex == 0)
 372   3                                      BCCTemp = SBUF1;
 373   3                              if(Packer.RecevieData[CIndex] == ETX)
 374   3                              {       
 375   4                                      Pointer_Packer = &Packer.Station.BCC;
 376   4                                      BCC = BCCTemp;                                          
 377   4                              }
 378   3                              else
 379   3                              {
 380   4                                      CIndex++;
 381   4                                      Pointer_Packer = &Packer.RecevieData[CIndex];
 382   4                                      
 383   4                              }
 384   3                      }
 385   2                      else if(Pointer_Packer == &Packer.Station.BCC)  
 386   2                      {
 387   3                              Pointer_Packer = &Packer.UART_Mark;
 388   3                              
 389   3                              if(BCC ==Packer.Station.BCC )
 390   3                                      RunCommand();
 391   3                              CIndex = 0;
 392   3                      }
 393   2                      else 
 394   2                      {       
 395   3                              Pointer_Packer = &Packer.UART_Mark;
 396   3                      }               
 397   2              }
 398   1              EIE2 |= 0x02;
 399   1      }
 400          
 401          //-----------------------------------------------------------------------------
 402          void Timer3_ISR (void) interrupt INTERRUPT_TIMER3 
 403          {
 404   1              TMR3CN &= 0x7F;
 405   1              if (RxTimeOutCountTimer3 ++ >=200)
 406   1              {
 407   2                      TMR3CN &= 0xFB;
 408   2                      TMR3H = 0xFF;
 409   2                      TMR3L = 0xFF;
 410   2                      RxTimeOutCountTimer3 = 0;
 411   2                      IsDrugTimeOut =1;
 412   2              }
 413   1      }
 414          //----------------------------------------------------------------------------
 415          void CassetMessageRev()
 416          {
 417   1              Packer.Tablet.State = Packer.CassetRev[0];
 418   1      }
 419          unsigned char BCC = 0x00,CassetIndex = 0x00;
 420          void UART0_Interrupt (void) interrupt 4  //接收CASSETE的資料
 421          {
 422   1         if (TI0 == 1)                   // Check if transmit flag is set
 423   1         {
 424   2            TI0 = 0;                           // Clear interrupt flag
 425   2            TX_Ready = 1;                    // Indicate transmission complete
 426   2      
 427   2         }
C51 COMPILER V9.51   STATION                                                               09/09/2018 15:04:57 PAGE 8   

 428   1         else if (RI0 == 1 )
 429   1         {
 430   2                  RI0 = 0;                           // Clear interrupt flag
 431   2                      *(CasetPointer_Packer) = SBUF0;
 432   2                      if (CasetPointer_Packer == &Packer.Cast_Mark)
 433   2                      {
 434   3                              if (Packer.Cast_Mark == UART_Mark)
 435   3                              {
 436   4                                      Packer.Cast_Mark = UART_NoMark ;
 437   4                                      CasetPointer_Packer = &Packer.CassetRev[CassetIndex];// &Packer.Tablet.State;
 438   4                              }
 439   3                              else
 440   3                              {       
 441   4                                      CassetIndex = 0;
 442   4                                      CasetPointer_Packer = &Packer.Cast_Mark;
 443   4                              }
 444   3                      }       
 445   2                      else if (CasetPointer_Packer == &Packer.CassetRev[CassetIndex])
 446   2                      {                                       
 447   3                              if(Packer.CassetRev[CassetIndex] == ETX)
 448   3                              {       
 449   4                                      CasetPointer_Packer = &Packer.Cast_Mark;                        
 450   4                                      CassetMessageRev();
 451   4                                      CassetIndex = 0;                                                        
 452   4                              }
 453   3                              else
 454   3                              {
 455   4                                      CassetIndex++;
 456   4                                      CasetPointer_Packer = &Packer.CassetRev[CassetIndex];
 457   4                                      
 458   4                              }       
 459   3                              
 460   3                      }
 461   2                      else 
 462   2                      {
 463   3                              CassetIndex = 0;
 464   3                              CasetPointer_Packer = &Packer.Cast_Mark;
 465   3                      }
 466   2                      
 467   2         }
 468   1      }
 469          
 470          //-----------------------------------------------------------------------------
 471          // End Of File
 472          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1926    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    124    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
